{"name":"LParticle","tagline":"HTML5 particle system based on Lufylegend","body":"# LParticle\r\n\r\nA component-based particle system library for HTML5 game engine [Lufylegend.js](https://github.com/lufylegend/lufylegend.js).\r\n\r\n## Description\r\nI'm writing HTML5 games with Lufylegend.js, which is a powerful and easy-to-use HTML5 game engine.\r\nBut this engine does not have a convenience particle systems class.\r\nSo I wrote this LParticle.js to create particle effects in HTML5 games. Hope it can help you.\r\n\r\n## Usage\r\nThere are two ways to use this library:\r\n\r\n1.  **Import by [coffeeify](https://github.com/substack/coffeeify).**\r\n    You can directly require the file `coffee/particle/particleSysrem.coffee`, and use the `ParticleSystem` class.\r\n\r\n2.  **Use global export.**\r\n    Import the generated bundle .js file in your html:\r\n\r\n    ` <script type=\"text/javascript\" src=\"lparticle.min.js\"></script>`\r\n\r\n    The particle system class is exported as  `LParticle.ParticleSystem`.\r\n\r\n\r\n## Structure\r\n\r\nThe main class, `LParticle.ParticleSystem`, is derived from `LSprite`.\r\nProperties of LSprite such as x, y, scaleX, scaleY and blendMode, are available to ParticleSystem.\r\nYou can add the particle system to any place in the scene graph.\r\nThis particle system class is designed as a component-based pattern.\r\nAn instance of `LParticle.ParticleSystem` keeps four types of components:\r\n\r\n*  **Emitters**: handle the emission of particles;\r\n*  **Initializers**: set initial properties of particles once they are created;\r\n*  **Affectors**: update properties of particles every frame;\r\n*  **Renderers**: implement draw particles every frame.\r\n\r\n\r\n## Sample Code\r\n\r\nPass a description of the components as the parameter of the constructor of ParticleSystem.\r\n\r\nTo create a particle effect and add it to the stage:\r\n\r\n    var pa = new LParticle.ParticleSystem(\r\n        {\r\n            emitters: [\r\n                {\r\n                    name: \"once\",     // emit all particles at once\r\n                    count: 50,        // emit totally 50 particles\r\n                    life: [0.3, 0.7]  // each particle has a random life from 0.3 to 0.7 seconds\r\n                }\r\n            ],\r\n            initializers: [\r\n                {\r\n                    name: \"radius\",   // initialize position and velocity on the edge of a circle\r\n                    radius: [0, 2],   // random radius of the circle from 0 to 2\r\n                    speed: [50, 180]  // random speed from 50 to 180\r\n                },\r\n                {\r\n                    name: \"rotation\", // initialize rotation\r\n                    angle: [0, 100]   // random angle from 0 to 100 radians\r\n                },\r\n                {\r\n                    name: \"color\",    // initialize color\r\n                    color: [200, [100, 150], 100, 1]  // r = 200, g = random from 100 to 150, b = 100, alpha = 1\r\n                }\r\n            ],\r\n            affectors: [\r\n                {\r\n                    name: \"move\"      // update the position according to velocity\r\n                },\r\n                {\r\n                    name: \"size\",     // update the size\r\n                    from: [5, 9],     // start size is random from 5 to 9\r\n                    to: 0             // end size is 0\r\n                }\r\n            ],\r\n            renderers: [\r\n                {\r\n                    name: \"box\"       // draw each particle as a rectangle\r\n                }\r\n            ]\r\n        }\r\n    );\r\n    pa.x = 100;\r\n    pa.y = 100;\r\n    pa.blendMode = LBlendMode.LIGHTER;\r\n    addChild(pa);\r\n\r\n## Random Properties\r\n\r\nAs shown in the above example, a number property can be expressed as a single number, which means the exact value,\r\nor as a two-element array, `[a, b]`, which means a random value from a to b.\r\n\r\n\r\n## Auto Removing\r\n\r\nBy default, a ParticleSystem object will be removed automatically from its parent when the effect is finished.\r\nThe condition is all the emitters have no future emissions and all the particles are disappeared.\r\nTo prevent this behavior, set the `removeOnFinish` property to `false`:\r\n\r\n```\r\nparticleObject.removeOnFinish = false;\r\n```\r\n\r\n## Built-in Components\r\n\r\n### Emitters\r\n\r\n\r\n    {\r\n        name: \"once\"  // emit all particles at once\r\n        count: 100    // total emission count\r\n        life: 0.5     // particle life, in seconds\r\n    }\r\n\r\n    {\r\n        name: \"infinite\"    // emit particles continuously\r\n        rate: 100           // emission per second\r\n        life: 0.5           // particle life, in seconds\r\n    }\r\n\r\n### Initializers\r\n\r\n    {\r\n        name: \"radius\"      // initialize position and velocity on the edge of a circle\r\n        radius: 10          // radius of the circle\r\n        speed: 5            // speed of particles, positive is towards outside of the circle\r\n    }\r\n\r\n    {\r\n        name: \"position\"    // initialize position\r\n        x: 10               // x\r\n        y: 50               // y\r\n    }\r\n\r\n    {\r\n        name: \"delta_speed\" // add extra speed to velocity\r\n        x: 10               // x\r\n        y: 50               // y\r\n        mul: 10             // multiplier, *optional*\r\n    }\r\n\r\n    {\r\n        name: \"force\"       // apply a constant force\r\n        x: 10               // x acceleration\r\n        y: 20               // y acceleration\r\n    }\r\n\r\n    {\r\n        name: \"rotation\"    // initial rotation\r\n        angle: 0.1          // radians\r\n    }\r\n\r\n    {\r\n        name: \"size\"        // initial size\r\n        size: 10            // size\r\n    }\r\n\r\n    {\r\n        name: \"color\"               // initial color\r\n        color: [255, 255, 255, 1]   // color, [r,g,b,a], rgb in [0, 255], a in [0, 1]\r\n    }\r\n\r\n    {\r\n        name: \"attach_node_pos\"     // set particles' position by another node's position, to create tailing effect\r\n        node: rootSprite            // a node object in the scene graph, such as LSprite, LShape, etc.\r\n    }\r\n\r\n### Affectors\r\n\r\n    {\r\n        name: \"move\"        // move particles by their velocity and acceleration\r\n    }\r\n\r\n    {\r\n        name: \"size\"        // change size during lifetime\r\n        from: 10            // size at start\r\n        to: 0               // size when then particle dies\r\n    }\r\n\r\n    {\r\n        name: \"color\"               // change color linearly\r\n        from: [255, 200, 100, 1]    // color at start, [r,g,b,a], rgb in [0, 255], a in [0, 1]\r\n        to: [0, 0, 0, 0]            // color when then particle dies, [r,g,b,a], rgb in [0, 255], a in [0, 1]\r\n    }\r\n\r\n    {\r\n        name: \"alpha\"       // change alpha during lifetime\r\n        from: 0.5           // alpha at start\r\n        to: 0               // alpha when then particle dies\r\n    }\r\n\r\n    {\r\n        name: \"rotation\"    // change rotation angle during lifetime\r\n        from: 10            // rotation at start\r\n        to: 0               // rotation when then particle dies\r\n    }\r\n\r\n### Renderers\r\n\r\n    {\r\n        name: \"box\"           // draw a rectangle for each particle\r\n    }\r\n\r\n    {\r\n        name: \"dot\"           // draw a dot for each particle\r\n    }\r\n\r\n    {\r\n        name: \"dot_fade\"      // draw a dot for each particle, with radial gradient\r\n    }\r\n\r\n    {\r\n        name: \"image\"         // draw an image for each particle\r\n        image: img          // image object\r\n    }\r\n\r\n## Custom Components\r\n\r\nYou can use your own emitters, initializers, affectors and renderers.\r\nYou need to create a class implementing following interface,\r\nand the class assign to the name:\r\n\r\nFor emitter:\r\n\r\n    // system: the particle system object,\r\n    // param: properties in description object\r\n    function MyEmitter(system, param) {}\r\n\r\n    // called per frame\r\n    MyEmitter.prototype.update = function(deltaTime) {}\r\n\r\n    // whether has future emissions\r\n    MyEmitter.prototype.isAlive = function() { return false; }\r\n\r\n    // register\r\n    LParticle.Emitter.my_emitter = MyEmitter\r\n\r\nFor initializer:\r\n\r\n    // system: the particle system object,\r\n    // param: properties in description object\r\n    function MyInitializer(system, param) {}\r\n\r\n    // called per particle once it's created\r\n    // p: particle object\r\n    MyInitializer.prototype.initParticle = function(p) {}\r\n\r\n    // register\r\n    LParticle.Initializer.my_initializer = MyInitializer\r\n\r\nFor affector:\r\n\r\n    // system: the particle system object,\r\n    // param: properties in description object\r\n    function MyAffector(system, param) {}\r\n\r\n    // called per particle once it's created\r\n    // p: particle object\r\n    MyAffector.prototype.initParticle = function(p) {}\r\n\r\n    // called per particle per frame\r\n    // p: particle object\r\n    MyAffector.prototype.updateParticle = function(deltaTime, p) {}\r\n\r\n    // register\r\n    LParticle.Affector.my_affector = MyAffector\r\n\r\nFor renderer:\r\n\r\n    // system: the particle system object,\r\n    // param: properties in description object\r\n    function MyRenderer(system, param) {}\r\n\r\n    // called per particle once it's created\r\n    // p: particle object\r\n    MyRenderer.prototype.initParticle = function(p) {}\r\n\r\n    // draw a particle\r\n    // ctx: canvas context\r\n    // p: particle object\r\n    MyRenderer.prototype.drawParticle = function(ctx, p) {}\r\n\r\n    // register\r\n    LParticle.Renderer.my_renderer = MyRenderer\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}